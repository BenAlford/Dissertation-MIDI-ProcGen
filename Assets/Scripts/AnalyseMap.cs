using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.Tilemaps;

public class RoomData
{
    public Vector2Int startPos = new Vector2Int();
    public Vector2Int size = new Vector2Int();
}

public class AnalyseMap : MonoBehaviour
{
    Tilemap map;
    public Tile groundTile;
    public GameObject exit;
    List<Vector2Int> foundRoomTiles = new List<Vector2Int>();
    List<RoomData> rooms = new List<RoomData>();
    public GameObject roomMarker;
    [SerializeField] LightingManager lightingManager;
    [SerializeField] GameObject coin;
    [SerializeField] GameObject enemy;
    [SerializeField] GameObject enemyRanged;

    List<Vector2Int> spawnedObjectLocs = new List<Vector2Int>();

    [SerializeField] MIDIfilepath MIDIfile;
    float arousal;

    public int maxEnemiesInRoom;
    [SerializeField] PlayMIDIFile playMidi;
    [SerializeField] GameObject LoadingScreen;

    float totalEnemies = 0;

    //public TestData test;


    public void Analyse(Vector2Int outputSize, Tilemap outputMap)
    {
        arousal = MIDIfile.arousal;
        map = outputMap;

        //finds the rooms generated by the WFC
        for (int x = 0; x < outputSize.x; x++)
        {
            for (int y = 0; y < outputSize.y; y++)
            {
                // if this tile is part of a room, and is not part of an already discovered room
                if (IsRoom(x, y) && !foundRoomTiles.Contains(new Vector2Int(x, y)))
                {
                    foundRoomTiles.Add(new Vector2Int(x, y));
                    FindRoomExtents(x,y);
                }
            }
        }

        //// Debug to see which rooms are recognised
        //for (int i = 0; i < rooms.Count; i++)
        //{
        //    GameObject newmarker = Instantiate(roomMarker);
        //    newmarker.transform.position = new Vector3(rooms[i].startPos.x, rooms[i].startPos.y);

        //    GameObject newmarker2 = Instantiate(roomMarker);
        //    newmarker2.transform.position = new Vector3(rooms[i].startPos.x + rooms[i].size.x, rooms[i].startPos.y + rooms[i].size.y);
        //}

        //SpawnCoins(3);

        // spawns the player in one of the identified rooms
        int playerSpawnRoom = Random.Range(0, rooms.Count);
        int playerSpawnX = rooms[playerSpawnRoom].startPos.x + Random.Range(0, rooms[playerSpawnRoom].size.x);
        int playerSpawnY = rooms[playerSpawnRoom].startPos.y + Random.Range(0, rooms[playerSpawnRoom].size.y);

        GameObject.FindGameObjectWithTag("Player").transform.position = new Vector3(playerSpawnX, playerSpawnY, 0);

        // creates a list of rooms that aren't the players spawn room
        List<int> unoccupiedRooms = new List<int>();
        for (int i = 0; i < rooms.Count; i++)
        {
            if (i != playerSpawnRoom)
            {
                unoccupiedRooms.Add(i);
            }
        }

        // spawns the exit in a room the player is not in
        int exitroom = unoccupiedRooms[Random.Range(0, unoccupiedRooms.Count)];

        // chooses a random position in the room to spawn
        int posX = Random.Range(rooms[exitroom].startPos.x, rooms[exitroom].startPos.x + rooms[exitroom].size.x);
        int posY = Random.Range(rooms[exitroom].startPos.y, rooms[exitroom].startPos.y + rooms[exitroom].size.y);

        // spawns the exit
        Instantiate(exit).transform.position = new Vector3(posX, posY);
        spawnedObjectLocs.Add(new Vector2Int(posX, posY));

        // spawns enemiess
        SpawnEnemies(unoccupiedRooms);

        lightingManager.SetRooms(rooms, playerSpawnRoom);

        GameObject.FindGameObjectWithTag("Player").GetComponent<PlayerBehaviour>().active = true;
        playMidi.StartMusic();
        LoadingScreen.SetActive(false);
        
        //// code for testing room size / enemy density
        //int totalRoomSize = 0;
        //for (int i = 0; i < rooms.Count; i++)
        //{
        //    totalRoomSize += (rooms[i].size.x + 3) * (rooms[i].size.y + 3);
        //}
        //float averageRoomSize = totalRoomSize / rooms.Count;
        //print(totalRoomSize / rooms.Count);
        //totalRoomSize -= (rooms[playerSpawnRoom].size.x + 3) * (rooms[playerSpawnRoom].size.y + 3);
        //print(totalEnemies / totalRoomSize);
        //float enemyDensity = totalEnemies / totalRoomSize;

        //Vector3 newData = new Vector3(arousal, averageRoomSize, enemyDensity);
        //test.data.Add(newData);

        //MIDIfile.arousal = Random.Range(1f,9f);
        //MIDIfile.seed = Random.Range(10000, 1000000);
        //SceneManager.LoadSceneAsync(3);
    }

    public bool IsRoom(int xStart, int yStart)
    {
        // checks a 3x3 square to see if it is all made of ground tiles
        for (int x = xStart-1; x <= xStart + 1; x++)
        {
            for (int y = yStart - 1; y <= yStart + 1; y++)
            {
                if (map.GetTile(new Vector3Int(x, y, 0)) != groundTile)
                {
                    return false;
                }
            }
        }
        return true;
    }

    public void FindRoomExtents(int startX, int startY)
    {
        // this algorithm assumes the room is found with the bottom right 3x3 square in the room, which is guarenteed
        // by the way the map is checked

        // finds how far the room extends along the x axis
        int extentX = startX;
        while(IsRoom(extentX + 1, startY))
        {
            foundRoomTiles.Add(new Vector2Int(extentX + 1, startY));
            extentX++;
        }

        // finds how far the room extends along the y axis
        int extentY = startY;

        while (IsRoom(startX, extentY + 1))
        {
            foundRoomTiles.Add(new Vector2Int(startX, extentY + 1));
            extentY++;
        }

        // marks every tile part of the room as found
        for (int x = startX + 1; x <= extentX; x++)
        {
            for (int y = startY + 1; y <= extentY; y++)
            {
                if (IsRoom(x,y))
                {
                    foundRoomTiles.Add(new Vector2Int(x, y));
                }
                else
                {
                    print("Room not square");
                }
            }
        }
        
        // adds the new room to the list
        RoomData newroom = new RoomData();
        newroom.startPos = new Vector2Int(startX, startY);
        newroom.size = new Vector2Int(extentX - startX, extentY - startY);
        rooms.Add(newroom);
    }

    void SpawnCoins(int coinCount)
    {
        // spawns coins across the rooms
        for (int i = 0; i < coinCount; i++)
        {
            int room = Random.Range(0, rooms.Count);

            for (int j = 0; j < 20; j++)
            {
                int posX = Random.Range(rooms[room].startPos.x - 1, rooms[room].startPos.x + rooms[room].size.x + 2);
                int posY = Random.Range(rooms[room].startPos.y - 1, rooms[room].startPos.y + rooms[room].size.y + 2);

                if (!spawnedObjectLocs.Contains(new Vector2Int(posX, posY)))
                {
                    Instantiate(coin).transform.position = new Vector2(posX, posY);
                    spawnedObjectLocs.Add(new Vector2Int(posX, posY));
                    break;
                }
            }
        }
    }

    void SpawnEnemies(List<int> enemyRooms)
    {
        for (int i = 0; i < enemyRooms.Count; i++)
        {
            // calculates the size of the room
            int size = (rooms[enemyRooms[i]].size.x + 2) * (rooms[enemyRooms[i]].size.y + 2);
            float sizeEnemyScaleFactor = 0;

            // sets the size scale factor accordingly
            if (size > 36)
            {
                sizeEnemyScaleFactor = 1;
            }
            else
            {
                sizeEnemyScaleFactor = size / 36f;
            }

            // sets the arousal scale factor
            float arousalScaleFactor = (arousal - 1) / 8;

            // calculates the enemies spawning in this room from those scale factors (guarentees one enemy)
            int enemies = Mathf.RoundToInt(1 + ((maxEnemiesInRoom-1) * sizeEnemyScaleFactor * arousalScaleFactor));
            totalEnemies += enemies;

            // spawns the enemy at a random location in the room
            for (int j = 0; j < enemies; j++)
            {
                for (int k = 0; k < 20; k++)
                {
                    int posX = Random.Range(rooms[enemyRooms[i]].startPos.x - 1, rooms[enemyRooms[i]].startPos.x + rooms[enemyRooms[i]].size.x + 2);
                    int posY = Random.Range(rooms[enemyRooms[i]].startPos.y - 1, rooms[enemyRooms[i]].startPos.y + rooms[enemyRooms[i]].size.y + 2);

                    // only spawns the enemy if the space is unnoccupied
                    if (!spawnedObjectLocs.Contains(new Vector2Int(posX, posY)))
                    {
                        // randomly chooses if it is a green or red slime
                        int enemyType = Random.Range(0, 2);
                        if (enemyType == 0)
                            Instantiate(enemy).transform.position = new Vector2(posX, posY);
                        else
                            Instantiate(enemyRanged).transform.position = new Vector2(posX, posY);
                        spawnedObjectLocs.Add(new Vector2Int(posX, posY));
                        break;
                    }
                }
            }
        }
    }
}
